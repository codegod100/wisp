<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Wisp Lisp - Widget Demo</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }
    h1 {
      color: white;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    .widget-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    .widget {
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      transition: transform 0.2s;
    }
    .widget:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    }
    .widget h2 {
      margin-top: 0;
      color: #667eea;
      border-bottom: 2px solid #667eea;
      padding-bottom: 10px;
    }
    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      margin: 5px;
      transition: background 0.2s;
    }
    button:hover {
      background: #5568d3;
    }
    input, textarea {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .result {
      background: #f5f5f5;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      min-height: 20px;
      font-family: monospace;
    }
    .calculator {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 5px;
    }
    .calculator button {
      padding: 15px;
      font-size: 18px;
    }
    .calculator .display {
      grid-column: 1 / -1;
      background: #2a2a2a;
      color: #4CAF50;
      padding: 15px;
      text-align: right;
      font-size: 24px;
      font-family: monospace;
      border-radius: 5px;
      margin-bottom: 10px;
    }
    .todo-item {
      display: flex;
      align-items: center;
      padding: 8px;
      margin: 5px 0;
      background: #f9f9f9;
      border-radius: 4px;
    }
    .todo-item input[type="checkbox"] {
      width: auto;
      margin-right: 10px;
    }
    .todo-item.completed {
      opacity: 0.6;
      text-decoration: line-through;
    }
    .code-editor {
      font-family: 'Courier New', monospace;
      background: #2a2a2a;
      color: #4CAF50;
      border: none;
      padding: 10px;
      border-radius: 5px;
      min-height: 100px;
    }
  </style>
</head>
<body>
  <h1>ðŸŽ¨ Wisp Lisp Widgets</h1>
  <p style="color: white; text-align: center; margin-bottom: 30px;">
    Interactive widgets built with Lisp running in WebAssembly
  </p>

  <div class="widget-container" id="widgets"></div>

  <script type="module">
    import { Wisp, WASD } from "./wisp.js";
    import WASI from "./wasi.js";
    import idom from "./lib/idom.js";

    let wispContext = null;
    let wasd = null;

    async function initWisp() {
      if (wispContext) return wispContext;

      const wasi = new WASI();
      wasd = new WASD();
      
      const wasmModule = await WebAssembly.compileStreaming(fetch("wisp.wasm"));
      const instance = await WebAssembly.instantiate(wasmModule, {
        wasi_snapshot_preview1: wasi.exports(),
        dom: wasd.exports()
      });

      wasi.setMemory(instance.exports.memory);
      wispContext = new Wisp(instance);
      wasd.setWisp(wispContext);
      
      return wispContext;
    }

    function exec(ctx, code) {
      const src = ctx.read(`(with-simple-error-handler (fn () (do ${code})))`);
      const run = ctx.api.wisp_run_init(ctx.heap, src);
      const result = ctx.api.wisp_run_eval(ctx.heap, run, 4_000_000) >>> 0;
      if (result === ctx.sys.zap) throw new Error("Evaluation failed");
      return result;
    }

    // Calculator Widget
    function createCalculator() {
      const widget = document.createElement('div');
      widget.className = 'widget';
      widget.innerHTML = `
        <h2>ðŸ§® Calculator</h2>
        <div class="calculator">
          <div class="display" id="calc-display">0</div>
          <button onclick="calcClear()">C</button>
          <button onclick="calcOp('/')">/</button>
          <button onclick="calcOp('*')">Ã—</button>
          <button onclick="calcOp('-')">-</button>
          <button onclick="calcNum('7')">7</button>
          <button onclick="calcNum('8')">8</button>
          <button onclick="calcNum('9')">9</button>
          <button onclick="calcOp('+')">+</button>
          <button onclick="calcNum('4')">4</button>
          <button onclick="calcNum('5')">5</button>
          <button onclick="calcNum('6')">6</button>
          <button onclick="calcEquals()" rowspan="2">=</button>
          <button onclick="calcNum('1')">1</button>
          <button onclick="calcNum('2')">2</button>
          <button onclick="calcNum('3')">3</button>
          <button onclick="calcNum('0')" colspan="2">0</button>
          <button onclick="calcNum('.')">.</button>
        </div>
      `;
      
      let display = '';
      let currentValue = 0;
      let operation = null;
      let waitingForOperand = false;

      window.calcNum = (num) => {
        if (waitingForOperand) {
          display = num;
          waitingForOperand = false;
        } else {
          display = display === '0' ? num : display + num;
        }
        document.getElementById('calc-display').textContent = display;
      };

      window.calcOp = (op) => {
        const inputValue = parseFloat(display);
        if (currentValue === 0) {
          currentValue = inputValue;
        } else {
          const result = calculate(currentValue, inputValue, operation);
          display = String(result);
          currentValue = result;
          document.getElementById('calc-display').textContent = display;
        }
        waitingForOperand = true;
        operation = op;
      };

      window.calcEquals = () => {
        const inputValue = parseFloat(display);
        if (operation) {
          const result = calculate(currentValue, inputValue, operation);
          display = String(result);
          currentValue = 0;
          operation = null;
          waitingForOperand = true;
          document.getElementById('calc-display').textContent = display;
        }
      };

      window.calcClear = () => {
        display = '0';
        currentValue = 0;
        operation = null;
        waitingForOperand = false;
        document.getElementById('calc-display').textContent = display;
      };

      function calculate(first, second, op) {
        switch(op) {
          case '+': return first + second;
          case '-': return first - second;
          case '*': return first * second;
          case '/': return first / second;
          default: return second;
        }
      }

      return widget;
    }

    // Todo List Widget
    function createTodoList() {
      const widget = document.createElement('div');
      widget.className = 'widget';
      widget.innerHTML = `
        <h2>âœ… Todo List</h2>
        <input type="text" id="todo-input" placeholder="Add a task...">
        <button onclick="addTodo()">Add</button>
        <div id="todo-list"></div>
      `;

      let todos = [];
      let todoId = 0;

      window.addTodo = () => {
        const input = document.getElementById('todo-input');
        const text = input.value.trim();
        if (text) {
          todos.push({ id: todoId++, text, completed: false });
          input.value = '';
          renderTodos();
        }
      };

      window.toggleTodo = (id) => {
        const todo = todos.find(t => t.id === id);
        if (todo) {
          todo.completed = !todo.completed;
          renderTodos();
        }
      };

      window.deleteTodo = (id) => {
        todos = todos.filter(t => t.id !== id);
        renderTodos();
      };

      function renderTodos() {
        const list = document.getElementById('todo-list');
        list.innerHTML = todos.map(todo => `
          <div class="todo-item ${todo.completed ? 'completed' : ''}">
            <input type="checkbox" ${todo.completed ? 'checked' : ''} 
                   onchange="toggleTodo(${todo.id})">
            <span style="flex: 1">${todo.text}</span>
            <button onclick="deleteTodo(${todo.id})" style="background: #f44336; padding: 5px 10px;">Ã—</button>
          </div>
        `).join('');
      }

      return widget;
    }

    // Lisp Code Runner Widget
    async function createLispRunner() {
      const ctx = await initWisp();
      const widget = document.createElement('div');
      widget.className = 'widget';
      widget.innerHTML = `
        <h2>ðŸ’» Lisp Code Runner</h2>
        <textarea class="code-editor" id="lisp-code" placeholder="Enter Lisp code here...">(+ 1 2 3)</textarea>
        <p style="font-size: 12px; color: #666; margin: 5px 0;">
          <strong>Try:</strong> <code>(+ 1 2 3)</code>, <code>(* 2 3)</code>, <code>(list 1 2 3)</code><br>
          <strong>Note:</strong> Load <code>format.wisp</code> first to use <code>format</code> function!
        </p>
        <button onclick="runLispCode()">Run</button>
        <div class="result" id="lisp-result">Result will appear here...</div>
      `;

      // Load format.wisp if not already loaded
      let formatLoaded = false;
      
      window.runLispCode = async () => {
        const code = document.getElementById('lisp-code').value.trim();
        const resultDiv = document.getElementById('lisp-result');
        
        if (!code) {
          resultDiv.innerHTML = '<span style="color: orange;">Please enter some code</span>';
          return;
        }
        
        // Try to load format.wisp if using format
        if (!formatLoaded && code.includes('format')) {
          try {
            resultDiv.innerHTML = '<span style="color: #666;">Loading format.wisp...</span>';
            const formatCode = await fetch('./format.wisp').then(x => x.text());
            // Load format.wisp code
            const formatSrc = ctx.read(`(with-simple-error-handler (fn () (do ${formatCode})))`);
            const formatRun = ctx.api.wisp_run_init(ctx.heap, formatSrc);
            const formatResult = ctx.api.wisp_run_eval(ctx.heap, formatRun, 4_000_000) >>> 0;
            if (formatResult === ctx.sys.zap) {
              console.error('format.wisp failed to load:', formatResult);
              resultDiv.innerHTML = '<span style="color: orange;">Warning: format.wisp failed to load. Some functions may not work.</span>';
            } else {
              formatLoaded = true;
              console.log('format.wisp loaded successfully');
            }
          } catch (e) {
            console.warn('Could not load format.wisp:', e);
            resultDiv.innerHTML = '<span style="color: orange;">Warning: Could not load format.wisp</span>';
          }
        }
        
        resultDiv.innerHTML = '<span style="color: #666;">Running...</span>';
        
        try {
          console.log('Reading code:', code);
          const src = ctx.read(code);
          console.log('Read result:', src);
          
          const run = ctx.api.wisp_run_init(ctx.heap, src);
          console.log('Run initialized:', run);
          
          const result = ctx.api.wisp_run_eval(ctx.heap, run, 4_000_000) >>> 0;
          console.log('Evaluation result:', result, 'hex:', '0x' + result.toString(16));
          console.log('System values:', {
            nil: ctx.sys.nil,
            t: ctx.sys.t,
            zap: ctx.sys.zap
          });

          if (result === ctx.sys.zap) {
            console.error('Evaluation returned zap (error)');
            resultDiv.innerHTML = '<span style="color: red;">Error: Evaluation failed (zap).<br><small>The function or syntax may not be available in Wisp. Try simpler code like <code>(+ 1 2)</code> or <code>(* 3 4)</code></small></span>';
            return;
          }

          try {
            const resultStr = formatResult(ctx, result);
            console.log('Formatted result:', resultStr);
            resultDiv.innerHTML = `<strong>Result:</strong> <code>${escapeHtml(resultStr)}</code>`;
          } catch (formatError) {
            console.error('Format error:', formatError);
            resultDiv.innerHTML = `<span style="color: orange;">Result: 0x${result.toString(16)} (format error: ${escapeHtml(formatError.message)})</span>`;
          }
        } catch (error) {
          console.error('Lisp execution error:', error);
          console.error('Stack:', error.stack);
          resultDiv.innerHTML = `<span style="color: red;">Error: ${escapeHtml(error.message)}<br><small>Check console for details</small></span>`;
        }
      };

      return widget;
    }

    // Counter Widget (Lisp-powered)
    async function createLispCounter() {
      const ctx = await initWisp();
      const widget = document.createElement('div');
      widget.className = 'widget';
      widget.innerHTML = `
        <h2>ðŸ”¢ Lisp Counter</h2>
        <div class="result" id="counter-display" style="font-size: 48px; text-align: center; padding: 20px;">0</div>
        <button onclick="counterIncrement()">+1</button>
        <button onclick="counterDecrement()">-1</button>
        <button onclick="counterReset()">Reset</button>
      `;

      let count = 0;

      window.counterIncrement = () => {
        try {
          // Use Lisp to increment
          const result = exec(ctx, `(+ ${count} 1)`);
          count = parseInt(formatResult(ctx, result)) || count + 1;
          document.getElementById('counter-display').textContent = count;
        } catch (e) {
          count++;
          document.getElementById('counter-display').textContent = count;
        }
      };

      window.counterDecrement = () => {
        try {
          // Use Lisp to decrement
          const result = exec(ctx, `(- ${count} 1)`);
          count = parseInt(formatResult(ctx, result)) || count - 1;
          document.getElementById('counter-display').textContent = count;
        } catch (e) {
          count--;
          document.getElementById('counter-display').textContent = count;
        }
      };

      window.counterReset = () => {
        count = 0;
        document.getElementById('counter-display').textContent = count;
      };

      return widget;
    }

    function formatResult(ctx, value) {
      value = value >>> 0;
      
      // Check for special system values first
      if (value === ctx.sys.nil) return "nil";
      if (value === ctx.sys.t) return "t";
      if (value === ctx.sys.zap) return "zap";
      
      // Integers: if bit 31 is 0, it's a 31-bit fixnum
      if ((value & 0x80000000) === 0) {
        // Sign extend if needed (31-bit signed integer)
        if (value & 0x40000000) {
          return (value | 0x80000000).toString();
        }
        return value.toString();
      }
      
      // Tagged pointers: extract tag from top 5 bits (bits 27-31)
      const tags = { 
        v08: 0x1a,  // byte vector
        v32: 0x19,  // word vector
        duo: 0x15,  // cons pair
        sym: 0x16,  // symbol
        fun: 0x17,  // function
        mac: 0x18,  // macro
        sys: 0x11,  // system value
        chr: 0x12,  // character
        jet: 0x13,  // builtin
        pin: 0x1f,  // pinned
      };
      
      let tag = (value >>> 27) & 0x1f;
      
      if (tag === tags.v08) {
        try { 
          return '"' + ctx.loadString(value) + '"'; 
        } catch (e) { 
          return `[string: 0x${value.toString(16)}]`; 
        }
      } else if (tag === tags.v32) {
        try {
          const vec = ctx.loadVector(value);
          return `[${vec.map(v => formatResult(ctx, v)).join(", ")}]`;
        } catch (e) { 
          return `[vector: 0x${value.toString(16)}]`; 
        }
      } else if (tag === tags.duo) {
        try {
          const head = ctx.api.wisp_heap_get_duo_head(ctx.heap, value) >>> 0;
          const tail = ctx.api.wisp_heap_get_duo_tail(ctx.heap, value) >>> 0;
          
          // Build list recursively
          let result = [];
          let current = value;
          let depth = 0;
          
          while (depth < 100) { // Prevent infinite loops
            const h = ctx.api.wisp_heap_get_duo_head(ctx.heap, current) >>> 0;
            const t = ctx.api.wisp_heap_get_duo_tail(ctx.heap, current) >>> 0;
            result.push(formatResult(ctx, h));
            
            if (t === ctx.sys.nil) {
              return `(${result.join(" ")})`;
            }
            
            // Check if tail is another cons
            const tailTag = (t >>> 27) & 0x1f;
            if (tailTag === tags.duo) {
              current = t;
              depth++;
            } else {
              return `(${result.join(" ")} . ${formatResult(ctx, t)})`;
            }
          }
          return `(${result.join(" ")} ...)`;
        } catch (e) { 
          return `[cons: 0x${value.toString(16)}]`; 
        }
      } else if (tag === tags.sym) {
        // Symbol - we can't easily get the name without more API functions
        // Just return a symbol indicator
        return `[symbol: 0x${value.toString(16)}]`;
      } else if (tag === tags.fun || tag === tags.mac) {
        // Function or macro
        return `[${tag === tags.fun ? 'function' : 'macro'}: 0x${value.toString(16)}]`;
      } else {
        return `[tag:0x${tag.toString(16)}: 0x${value.toString(16)}]`;
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // Fibonacci Widget (pure Lisp)
    async function createFibonacciWidget() {
      const ctx = await initWisp();
      const widget = document.createElement('div');
      widget.className = 'widget';
      widget.innerHTML = `
        <h2>ðŸ”¢ Fibonacci Generator</h2>
        <p>Calculate Fibonacci numbers using Lisp recursion</p>
        <input type="number" id="fib-input" value="10" min="0" max="30" style="width: 100px;">
        <button onclick="calculateFib()">Calculate</button>
        <div class="result" id="fib-result">Enter a number and click Calculate</div>
        <div class="result" id="fib-sequence" style="max-height: 200px; overflow-y: auto;"></div>
      `;

      window.calculateFib = async () => {
        const n = parseInt(document.getElementById('fib-input').value) || 0;
        const resultDiv = document.getElementById('fib-result');
        const seqDiv = document.getElementById('fib-sequence');
        
        try {
          // Define fibonacci function in Lisp and call it
          // We need to evaluate the defun first, then call it
          const defunCode = `
            (defun fib (n)
              (if (< n 2)
                  n
                (+ (fib (- n 1)) (fib (- n 2)))))
          `;
          
          // Evaluate the function definition
          const defunSrc = ctx.read(defunCode);
          const defunRun = ctx.api.wisp_run_init(ctx.heap, defunSrc);
          const defunResult = ctx.api.wisp_run_eval(ctx.heap, defunRun, 4_000_000) >>> 0;
          
          if (defunResult === ctx.sys.zap) {
            resultDiv.innerHTML = '<span style="color: red;">Error: Function definition failed</span>';
            return;
          }
          
          // Now call the function
          const callCode = `(fib ${n})`;
          
          const callSrc = ctx.read(callCode);
          const callRun = ctx.api.wisp_run_init(ctx.heap, callSrc);
          const result = ctx.api.wisp_run_eval(ctx.heap, callRun, 4_000_000) >>> 0;

          if (result === ctx.sys.zap) {
            resultDiv.innerHTML = '<span style="color: red;">Error: Calculation failed</span>';
            return;
          }

          const fibValue = formatResult(ctx, result);
          resultDiv.innerHTML = `<strong>Fibonacci(${n}) = ${fibValue}</strong>`;
          
          // Generate sequence
          let sequence = [];
          for (let i = 0; i <= Math.min(n, 15); i++) {
            try {
              // Function is already defined, just call it
              const seqCallCode = `(fib ${i})`;
              const seqCallSrc = ctx.read(seqCallCode);
              const seqCallRun = ctx.api.wisp_run_init(ctx.heap, seqCallSrc);
              const seqResult = ctx.api.wisp_run_eval(ctx.heap, seqCallRun, 4_000_000) >>> 0;
              if (seqResult !== ctx.sys.zap) {
                sequence.push(formatResult(ctx, seqResult));
              }
            } catch (e) {
              break;
            }
          }
          
          seqDiv.innerHTML = `<strong>Sequence:</strong> ${sequence.join(', ')}`;
        } catch (error) {
          resultDiv.innerHTML = `<span style="color: red;">Error: ${escapeHtml(error.message)}</span>`;
        }
      };

      return widget;
    }

    // Initialize and create widgets
    async function init() {
      await initWisp();
      
      const container = document.getElementById('widgets');
      container.appendChild(createCalculator());
      container.appendChild(createTodoList());
      container.appendChild(await createLispRunner());
      container.appendChild(await createLispCounter());
      container.appendChild(await createFibonacciWidget());
    }

    init();
  </script>
</body>
</html>

