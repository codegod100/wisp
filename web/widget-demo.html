<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Wisp Lisp - Widget Demo</title>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
    }
    h1 {
      color: white;
      text-align: center;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }
    .widget-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
      gap: 20px;
      margin: 20px 0;
    }
    .widget {
      background: white;
      border-radius: 10px;
      padding: 20px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
      transition: transform 0.2s;
    }
    .widget:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(0,0,0,0.15);
    }
    .widget h2 {
      margin-top: 0;
      color: #667eea;
      border-bottom: 2px solid #667eea;
      padding-bottom: 10px;
    }
    button {
      background: #667eea;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
      margin: 5px;
      transition: background 0.2s;
    }
    button:hover {
      background: #5568d3;
    }
    input, textarea {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
      border: 1px solid #ddd;
      border-radius: 4px;
      box-sizing: border-box;
    }
    .result {
      background: #f5f5f5;
      padding: 10px;
      border-radius: 5px;
      margin: 10px 0;
      min-height: 20px;
      font-family: monospace;
    }
    .calculator {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 5px;
    }
    .calculator button {
      padding: 15px;
      font-size: 18px;
    }
    .calculator .display {
      grid-column: 1 / -1;
      background: #2a2a2a;
      color: #4CAF50;
      padding: 15px;
      text-align: right;
      font-size: 24px;
      font-family: monospace;
      border-radius: 5px;
      margin-bottom: 10px;
    }
    .todo-item {
      display: flex;
      align-items: center;
      padding: 8px;
      margin: 5px 0;
      background: #f9f9f9;
      border-radius: 4px;
    }
    .todo-item input[type="checkbox"] {
      width: auto;
      margin-right: 10px;
    }
    .todo-item.completed {
      opacity: 0.6;
      text-decoration: line-through;
    }
    .code-editor {
      font-family: 'Courier New', monospace;
      background: #2a2a2a;
      color: #4CAF50;
      border: none;
      padding: 10px;
      border-radius: 5px;
      min-height: 100px;
    }
  </style>
</head>
<body>
  <h1>üé® Wisp Lisp Widgets</h1>
  <p style="color: white; text-align: center; margin-bottom: 30px;">
    Interactive widgets built with Lisp running in WebAssembly
  </p>

  <div class="widget-container" id="widgets"></div>

  <script type="module">
    import { Wisp, WASD } from "./wisp.js";
    import WASI from "./wasi.js";
    import idom from "./lib/idom.js";

    let wispContext = null;
    let wasd = null;

    async function initWisp() {
      if (wispContext) return wispContext;

      const wasi = new WASI();
      wasd = new WASD();
      
      const wasmModule = await WebAssembly.compileStreaming(fetch("wisp.wasm"));
      const instance = await WebAssembly.instantiate(wasmModule, {
        wasi_snapshot_preview1: wasi.exports(),
        dom: wasd.exports()
      });

      wasi.setMemory(instance.exports.memory);
      wispContext = new Wisp(instance);
      wasd.setWisp(wispContext);
      window.wasd = wasd; // Make wasd accessible globally
      
      return wispContext;
    }

    function exec(ctx, code) {
      const src = ctx.read(`(with-simple-error-handler (fn () (do ${code})))`);
      const run = ctx.api.wisp_run_init(ctx.heap, src);
      const result = ctx.api.wisp_run_eval(ctx.heap, run, 4_000_000) >>> 0;
      if (result === ctx.sys.zap) throw new Error("Evaluation failed");
      return result;
    }

    // Calculator Widget
    function createCalculator() {
      const widget = document.createElement('div');
      widget.className = 'widget';
      widget.innerHTML = `
        <h2>üßÆ Calculator</h2>
        <div class="calculator">
          <div class="display" id="calc-display">0</div>
          <button onclick="calcClear()">C</button>
          <button onclick="calcOp('/')">/</button>
          <button onclick="calcOp('*')">√ó</button>
          <button onclick="calcOp('-')">-</button>
          <button onclick="calcNum('7')">7</button>
          <button onclick="calcNum('8')">8</button>
          <button onclick="calcNum('9')">9</button>
          <button onclick="calcOp('+')">+</button>
          <button onclick="calcNum('4')">4</button>
          <button onclick="calcNum('5')">5</button>
          <button onclick="calcNum('6')">6</button>
          <button onclick="calcEquals()" rowspan="2">=</button>
          <button onclick="calcNum('1')">1</button>
          <button onclick="calcNum('2')">2</button>
          <button onclick="calcNum('3')">3</button>
          <button onclick="calcNum('0')" colspan="2">0</button>
          <button onclick="calcNum('.')">.</button>
        </div>
      `;
      
      let display = '';
      let currentValue = 0;
      let operation = null;
      let waitingForOperand = false;

      window.calcNum = (num) => {
        if (waitingForOperand) {
          display = num;
          waitingForOperand = false;
        } else {
          display = display === '0' ? num : display + num;
        }
        document.getElementById('calc-display').textContent = display;
      };

      window.calcOp = (op) => {
        const inputValue = parseFloat(display);
        if (currentValue === 0) {
          currentValue = inputValue;
        } else {
          const result = calculate(currentValue, inputValue, operation);
          display = String(result);
          currentValue = result;
          document.getElementById('calc-display').textContent = display;
        }
        waitingForOperand = true;
        operation = op;
      };

      window.calcEquals = () => {
        const inputValue = parseFloat(display);
        if (operation) {
          const result = calculate(currentValue, inputValue, operation);
          display = String(result);
          currentValue = 0;
          operation = null;
          waitingForOperand = true;
          document.getElementById('calc-display').textContent = display;
        }
      };

      window.calcClear = () => {
        display = '0';
        currentValue = 0;
        operation = null;
        waitingForOperand = false;
        document.getElementById('calc-display').textContent = display;
      };

      function calculate(first, second, op) {
        switch(op) {
          case '+': return first + second;
          case '-': return first - second;
          case '*': return first * second;
          case '/': return first / second;
          default: return second;
        }
      }

      return widget;
    }

    // Todo List Widget
    function createTodoList() {
      const widget = document.createElement('div');
      widget.className = 'widget';
      widget.innerHTML = `
        <h2>‚úÖ Todo List</h2>
        <input type="text" id="todo-input" placeholder="Add a task...">
        <button onclick="addTodo()">Add</button>
        <div id="todo-list"></div>
      `;

      let todos = [];
      let todoId = 0;

      window.addTodo = () => {
        const input = document.getElementById('todo-input');
        const text = input.value.trim();
        if (text) {
          todos.push({ id: todoId++, text, completed: false });
          input.value = '';
          renderTodos();
        }
      };

      window.toggleTodo = (id) => {
        const todo = todos.find(t => t.id === id);
        if (todo) {
          todo.completed = !todo.completed;
          renderTodos();
        }
      };

      window.deleteTodo = (id) => {
        todos = todos.filter(t => t.id !== id);
        renderTodos();
      };

      function renderTodos() {
        const list = document.getElementById('todo-list');
        list.innerHTML = todos.map(todo => `
          <div class="todo-item ${todo.completed ? 'completed' : ''}">
            <input type="checkbox" ${todo.completed ? 'checked' : ''} 
                   onchange="toggleTodo(${todo.id})">
            <span style="flex: 1">${todo.text}</span>
            <button onclick="deleteTodo(${todo.id})" style="background: #f44336; padding: 5px 10px;">√ó</button>
          </div>
        `).join('');
      }

      return widget;
    }

    // Lisp Code Runner Widget
    async function createLispRunner() {
      const ctx = await initWisp();
      const widget = document.createElement('div');
      widget.className = 'widget';
      widget.innerHTML = `
        <h2>üíª Lisp Code Runner</h2>
        <textarea class="code-editor" id="lisp-code" placeholder="Enter Lisp code here...">(+ 1 2 3)</textarea>
        <p style="font-size: 0.85em; color: #888; margin-top: 8px;">
          <strong>Debug fetch:</strong> Try these in order:<br>
          <code>*window*</code> - Check if *window* is set<br>
          <code>(js-object)</code> - Test js-object with no args<br>
          <code>(send! :async "test")</code> - Test send! (should fail if no prompt)<br>
          <code>(js-call (js-global-this) "fetch" "https://api.github.com/users/octocat" (js-object))</code> - Direct fetch call
        </p>
        <p style="font-size: 0.85em; color: #888; margin-top: 8px;">
          <strong>Note:</strong> For <code>fetch</code>, try: <code>(js-global-this)</code> first to test if browser APIs work
        </p>
        <p style="font-size: 12px; color: #666; margin: 5px 0;">
          <strong>Try:</strong> <code>(+ 1 2 3)</code>, <code>(* 2 3)</code>, <code>(list 1 2 3)</code><br>
          <strong>Note:</strong> Load <code>format.wisp</code> first to use <code>format</code> function!
        </p>
        <button onclick="runLispCode()">Run</button>
        <div class="result" id="lisp-result">Result will appear here...</div>
      `;

      // Load format.wisp and js.wisp if not already loaded
      let formatLoaded = false;
      let jsLoaded = false;
      
      async function loadWispFile(filename) {
        try {
          const code = await fetch(`./${filename}`).then(x => x.text());
          // Use readMany to load multiple forms, then evaluate each one
          const forms = ctx.readMany(code);
          if (forms === ctx.sys.zap) {
            console.error(`${filename} failed to parse`);
            return false;
          }
          
          // Evaluate each form in the file
          let current = forms;
          let formIndex = 0;
          while (current !== ctx.sys.nil) {
            formIndex++;
            const form = ctx.api.wisp_heap_get_duo_head(ctx.heap, current) >>> 0;
            const run = ctx.api.wisp_run_init(ctx.heap, form);
            const result = ctx.api.wisp_run_eval(ctx.heap, run, 4_000_000) >>> 0;
            if (result === ctx.sys.zap) {
              const runErr = ctx.api.wisp_run_err(ctx.heap, run);
              const runExp = ctx.api.wisp_run_exp(ctx.heap, run);
              console.error(`${filename} form ${formIndex} failed:`, runErr, runExp);
              // Try to format the expression to see what failed
              try {
                const expStr = formatResult(ctx, runExp);
                console.error(`Failed form ${formIndex}:`, expStr);
              } catch (e) {
                console.error('Could not format failed form:', e);
              }
              // Continue loading other forms even if one fails
            }
            current = ctx.api.wisp_heap_get_duo_tail(ctx.heap, current) >>> 0;
          }
          
          console.log(`${filename} loaded successfully`);
          return true;
        } catch (e) {
          console.warn(`Could not load ${filename}:`, e);
          return false;
        }
      }
      
      window.runLispCode = async () => {
        const code = document.getElementById('lisp-code').value.trim();
        const resultDiv = document.getElementById('lisp-result');
        
        if (!code) {
          resultDiv.innerHTML = '<span style="color: orange;">Please enter some code</span>';
          return;
        }
        
        // Try to load js.wisp if using fetch, response-text, or other JS functions
        // Note: base.wisp is already in boot.core, so we don't need to load it
        if (!jsLoaded && (code.includes('fetch') || code.includes('response-text') || 
                          code.includes('js-call') || code.includes('js-get') || 
                          code.includes('await') || code.includes('async'))) {
          try {
            resultDiv.innerHTML = '<span style="color: #666;">Loading js.wisp...</span>';
            jsLoaded = await loadWispFile('js.wisp');
            if (!jsLoaded) {
              resultDiv.innerHTML = '<span style="color: orange;">Warning: js.wisp failed to load. fetch and other JS functions may not work.</span>';
            } else {
              // After loading js.wisp, verify *window* is set, and set it manually if needed
              try {
                const testWindow = ctx.read('*window*');
                const testRun = ctx.api.wisp_run_init(ctx.heap, testWindow);
                const testResult = ctx.api.wisp_run_eval(ctx.heap, testRun, 4_000_000) >>> 0;
                if (testResult === ctx.sys.zap) {
                  console.warn('*window* is not set, setting it manually...');
                  // Set *window* manually
                  const setWindowCode = ctx.read('(set-symbol-value! (quote *window*) (js-global-this))');
                  const setWindowRun = ctx.api.wisp_run_init(ctx.heap, setWindowCode);
                  const setWindowResult = ctx.api.wisp_run_eval(ctx.heap, setWindowRun, 4_000_000) >>> 0;
                  if (setWindowResult === ctx.sys.zap) {
                    console.error('Failed to set *window* manually');
                  } else {
                    console.log('*window* set manually');
                  }
              } else {
                console.log('*window* is already set');
              }
              
              // Define a simpler fetch that doesn't use await
              // The regular fetch uses await/send! which requires prompt handlers
              // This version returns the promise directly, which you can handle with js-then
              try {
                const simpleFetchCode = ctx.read(`
                  (defun fetch-simple (url)
                    (js-call *window* "fetch" url (js-object)))
                  
                  (defun response-text-simple (response)
                    (js-call response "text"))
                `);
                const simpleFetchRun = ctx.api.wisp_run_init(ctx.heap, simpleFetchCode);
                const simpleFetchResult = ctx.api.wisp_run_eval(ctx.heap, simpleFetchRun, 4_000_000) >>> 0;
                if (simpleFetchResult === ctx.sys.zap) {
                  console.warn('Failed to define fetch-simple');
                } else {
                  console.log('fetch-simple and response-text-simple defined');
                  console.log('Note: fetch-simple returns a promise. Use js-then to handle it.');
                }
              } catch (e) {
                console.warn('Could not define fetch-simple:', e);
              }
            } catch (e) {
              console.warn('Could not verify *window*:', e);
            }
          }
          } catch (e) {
            console.warn('Could not load js.wisp:', e);
            resultDiv.innerHTML = '<span style="color: orange;">Warning: Could not load js.wisp</span>';
          }
        }
        
        // Try to load format.wisp if using format
        if (!formatLoaded && code.includes('format')) {
          try {
            resultDiv.innerHTML = '<span style="color: #666;">Loading format.wisp...</span>';
            formatLoaded = await loadWispFile('format.wisp');
            if (!formatLoaded) {
              resultDiv.innerHTML = '<span style="color: orange;">Warning: format.wisp failed to load. Some functions may not work.</span>';
            }
          } catch (e) {
            console.warn('Could not load format.wisp:', e);
            resultDiv.innerHTML = '<span style="color: orange;">Warning: Could not load format.wisp</span>';
          }
        }
        
        resultDiv.innerHTML = '<span style="color: #666;">Running...</span>';
        
        try {
          console.log('Reading code:', code);
          
          // Try to read multiple expressions first
          let forms = ctx.readMany(code);
          let lastResult = ctx.sys.nil;
          
          if (forms === ctx.sys.zap) {
            // If readMany fails, try reading a single expression
            forms = ctx.read(code);
            if (forms === ctx.sys.zap) {
              resultDiv.innerHTML = '<span style="color: red;">Error: Failed to parse code</span>';
              return;
            }
            // Single expression - evaluate it directly
            const run = ctx.api.wisp_run_init(ctx.heap, forms);
            console.log('Run initialized:', run);
            lastResult = ctx.api.wisp_run_eval(ctx.heap, run, 4_000_000) >>> 0;
          } else {
            // Multiple expressions - evaluate each one in sequence
            console.log('Read multiple expressions, forms:', forms);
            
            // Check if forms is actually a duo (list)
            const tags = {
              duo: 0x15,
              v08: 0x1a,
              v32: 0x19,
              sym: 0x14,
              fun: 0x16,
              mac: 0x17,
            };
            const formsTag = (forms >>> 27) & 0x1f;
            console.log('Forms tag:', formsTag.toString(16), 'expected duo:', tags.duo.toString(16));
            
            if (formsTag !== tags.duo) {
              console.error('readMany did not return a list (duo), got tag:', formsTag);
              resultDiv.innerHTML = '<span style="color: red;">Error: Failed to parse multiple expressions</span>';
              return;
            }
            
            let current = forms;
            let formCount = 0;
            
            while (current !== ctx.sys.nil) {
              // Verify current is a duo before accessing
              const currentTag = (current >>> 27) & 0x1f;
              if (currentTag !== tags.duo && current !== ctx.sys.nil) {
                console.error('Expected duo or nil, got tag:', currentTag, 'value:', current);
                break;
              }
              
              const form = ctx.api.wisp_heap_get_duo_head(ctx.heap, current) >>> 0;
              formCount++;
              console.log(`Evaluating form ${formCount}:`, form);
              
              const run = ctx.api.wisp_run_init(ctx.heap, form);
              lastResult = ctx.api.wisp_run_eval(ctx.heap, run, 4_000_000) >>> 0;
              
              if (lastResult === ctx.sys.zap) {
                // Try to get error details from the run
                try {
                  const runErr = ctx.api.wisp_run_err(ctx.heap, run);
                  const runExp = ctx.api.wisp_run_exp(ctx.heap, run);
                  console.error(`Form ${formCount} returned zap (error)`);
                  console.error('Error value:', runErr, 'hex:', '0x' + runErr.toString(16));
                  console.error('Expression:', runExp, 'hex:', '0x' + runExp.toString(16));
                  
                  // Try to format the expression that failed
                  try {
                    const expStr = formatResult(ctx, runExp);
                    console.error('Failed expression:', expStr);
                  } catch (e) {
                    console.error('Could not format expression:', e);
                  }
                  
                  if (runErr !== ctx.sys.nil) {
                    try {
                      const errStr = formatResult(ctx, runErr);
                      console.error('Error details:', errStr);
                    } catch (e) {
                      console.error('Could not format error:', e);
                    }
                  }
                } catch (e) {
                  console.error(`Form ${formCount} returned zap (error) - could not get details:`, e);
                }
                break;
              }
              
              current = ctx.api.wisp_heap_get_duo_tail(ctx.heap, current) >>> 0;
            }
            
            console.log(`Evaluated ${formCount} form(s)`);
          }
          
          console.log('Evaluation result:', lastResult, 'hex:', '0x' + lastResult.toString(16));
          console.log('System values:', {
            nil: ctx.sys.nil,
            t: ctx.sys.t,
            zap: ctx.sys.zap
          });

          if (lastResult === ctx.sys.zap) {
            console.error('Evaluation returned zap (error)');
            resultDiv.innerHTML = '<span style="color: red;">Error: Evaluation failed (zap).<br><small>The function or syntax may not be available in Wisp. Try simpler code like <code>(+ 1 2)</code> or <code>(* 3 4)</code></small></span>';
            return;
          }

          try {
            const resultStr = formatResult(ctx, lastResult);
            console.log('Formatted result:', resultStr);
            resultDiv.innerHTML = `<strong>Result:</strong> <code>${escapeHtml(resultStr)}</code>`;
          } catch (formatError) {
            console.error('Format error:', formatError);
            resultDiv.innerHTML = `<span style="color: orange;">Result: 0x${lastResult.toString(16)} (format error: ${escapeHtml(formatError.message)})</span>`;
          }
        } catch (error) {
          console.error('Lisp execution error:', error);
          console.error('Stack:', error.stack);
          resultDiv.innerHTML = `<span style="color: red;">Error: ${escapeHtml(error.message)}<br><small>Check console for details</small></span>`;
        }
      };

      return widget;
    }

    // Counter Widget (Lisp-powered)
    async function createLispCounter() {
      const ctx = await initWisp();
      const widget = document.createElement('div');
      widget.className = 'widget';
      widget.innerHTML = `
        <h2>üî¢ Lisp Counter</h2>
        <div class="result" id="counter-display" style="font-size: 48px; text-align: center; padding: 20px;">0</div>
        <button onclick="counterIncrement()">+1</button>
        <button onclick="counterDecrement()">-1</button>
        <button onclick="counterReset()">Reset</button>
      `;

      let count = 0;

      window.counterIncrement = () => {
        try {
          // Use Lisp to increment
          const result = exec(ctx, `(+ ${count} 1)`);
          count = parseInt(formatResult(ctx, result)) || count + 1;
          document.getElementById('counter-display').textContent = count;
        } catch (e) {
          count++;
          document.getElementById('counter-display').textContent = count;
        }
      };

      window.counterDecrement = () => {
        try {
          // Use Lisp to decrement
          const result = exec(ctx, `(- ${count} 1)`);
          count = parseInt(formatResult(ctx, result)) || count - 1;
          document.getElementById('counter-display').textContent = count;
        } catch (e) {
          count--;
          document.getElementById('counter-display').textContent = count;
        }
      };

      window.counterReset = () => {
        count = 0;
        document.getElementById('counter-display').textContent = count;
      };

      return widget;
    }

    function formatResult(ctx, value) {
      value = value >>> 0;
      
      // Check for special system values first
      if (value === ctx.sys.nil) return "nil";
      if (value === ctx.sys.t) return "t";
      if (value === ctx.sys.zap) return "zap";
      
      // Integers: if bit 31 is 0, it's a 31-bit fixnum
      if ((value & 0x80000000) === 0) {
        // Sign extend if needed (31-bit signed integer)
        if (value & 0x40000000) {
          return (value | 0x80000000).toString();
        }
        return value.toString();
      }
      
      // Tagged pointers: extract tag from top 5 bits (bits 27-31)
      const tags = { 
        v08: 0x1a,  // byte vector
        v32: 0x19,  // word vector
        duo: 0x15,  // cons pair
        sym: 0x16,  // symbol
        fun: 0x17,  // function
        mac: 0x18,  // macro
        sys: 0x11,  // system value
        chr: 0x12,  // character
        jet: 0x13,  // builtin
        pin: 0x1f,  // pinned
      };
      
      let tag = (value >>> 27) & 0x1f;
      
      if (tag === tags.v08) {
        try { 
          return '"' + ctx.loadString(value) + '"'; 
        } catch (e) { 
          return `[string: 0x${value.toString(16)}]`; 
        }
      } else if (tag === tags.v32) {
        try {
          const vec = ctx.loadVector(value);
          return `[${vec.map(v => formatResult(ctx, v)).join(", ")}]`;
        } catch (e) { 
          return `[vector: 0x${value.toString(16)}]`; 
        }
      } else if (tag === tags.duo) {
        try {
          const head = ctx.api.wisp_heap_get_duo_head(ctx.heap, value) >>> 0;
          const tail = ctx.api.wisp_heap_get_duo_tail(ctx.heap, value) >>> 0;
          
          // Build list recursively
          let result = [];
          let current = value;
          let depth = 0;
          
          while (depth < 100) { // Prevent infinite loops
            const h = ctx.api.wisp_heap_get_duo_head(ctx.heap, current) >>> 0;
            const t = ctx.api.wisp_heap_get_duo_tail(ctx.heap, current) >>> 0;
            result.push(formatResult(ctx, h));
            
            if (t === ctx.sys.nil) {
              return `(${result.join(" ")})`;
            }
            
            // Check if tail is another cons
            const tailTag = (t >>> 27) & 0x1f;
            if (tailTag === tags.duo) {
              current = t;
              depth++;
            } else {
              return `(${result.join(" ")} . ${formatResult(ctx, t)})`;
            }
          }
          return `(${result.join(" ")} ...)`;
        } catch (e) { 
          return `[cons: 0x${value.toString(16)}]`; 
        }
      } else if (tag === tags.sym) {
        // Symbol - we can't easily get the name without more API functions
        // Just return a symbol indicator
        return `[symbol: 0x${value.toString(16)}]`;
      } else if (tag === tags.fun || tag === tags.mac) {
        // Function or macro
        return `[${tag === tags.fun ? 'function' : 'macro'}: 0x${value.toString(16)}]`;
      } else {
        return `[tag:0x${tag.toString(16)}: 0x${value.toString(16)}]`;
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // HTTP Request Widget
    async function createHttpRequestWidget() {
      const ctx = await initWisp();
      
      // Set up a global error handler that's always active
      // This prevents SEND-WITH-DEFAULT! from failing when no prompt handler is found
      const globalErrorHandlerCode = ctx.read(`
        (defvar *global-error-handler-active* nil)
        
        ;; This will be called whenever an error occurs
        ;; We set it up by wrapping all evaluations in a prompt handler
      `);
      const globalErrorHandlerRun = ctx.api.wisp_run_init(ctx.heap, globalErrorHandlerCode);
      ctx.api.wisp_run_eval(ctx.heap, globalErrorHandlerRun, 4_000_000) >>> 0;
      
      // Make sure js.wisp is loaded
      if (!window.jsLoaded) {
        try {
          const code = await fetch('./js.wisp').then(x => x.text());
          const forms = ctx.readMany(code);
          if (forms !== ctx.sys.zap) {
            let current = forms;
            while (current !== ctx.sys.nil) {
              const form = ctx.api.wisp_heap_get_duo_head(ctx.heap, current) >>> 0;
              // Evaluate each form - errors will be caught by the global handler if set up
              const run = ctx.api.wisp_run_init(ctx.heap, form);
              const result = ctx.api.wisp_run_eval(ctx.heap, run, 4_000_000) >>> 0;
              if (result === ctx.sys.zap) {
                console.warn('Form evaluation returned zap, but continuing...');
              }
              current = ctx.api.wisp_heap_get_duo_tail(ctx.heap, current) >>> 0;
            }
            // Define HTTP request handler and DOM helpers in Lisp
            // First ensure *window* is set
            try {
              const setWindowCode = ctx.read('(try (set-symbol-value! (quote *window*) (js-global-this)) (catch (e k) nil))');
              const setWindowRun = ctx.api.wisp_run_init(ctx.heap, setWindowCode);
              ctx.api.wisp_run_eval(ctx.heap, setWindowRun, 4_000_000) >>> 0;
            } catch (e) {
              console.warn('Could not set *window*:', e);
            }
            
            const httpCode = ctx.read(`
              ;; DOM manipulation helpers
              (defun element-get-value (id)
                (js-get (query-selector (string-append "#" id)) "value"))
              
              (defun element-set-html (id html)
                (js-set! (query-selector (string-append "#" id)) "innerHTML" html))
              
              (defun element-set-text (id text)
                (js-set! (query-selector (string-append "#" id)) "textContent" text))
              
              ;; Complete HTTP request handler - mostly Lisp, minimal JS glue
              ;; Simplified: just get URL and return fetch promise, handle response in JS
              (defun http-request (url-id result-id)
                (let ((url (element-get-value url-id)))
                  (if (nil? url)
                      (do
                        (element-set-html result-id "<span style=\\"color: orange;\\">Please enter a URL</span>")
                        nil)
                    (do
                      ;; Show loading state
                      (element-set-html result-id "<span style=\\"color: #e0e0e0;\\">Loading...</span>")
                      ;; Return the fetch promise - JS will handle the response
                      (js-call *window* "fetch" url)))))
            `);
            const httpRun = ctx.api.wisp_run_init(ctx.heap, httpCode);
            ctx.api.wisp_run_eval(ctx.heap, httpRun, 4_000_000) >>> 0;
            window.jsLoaded = true;
          }
        } catch (e) {
          console.warn('Could not load js.wisp for HTTP widget:', e);
        }
      }
      
      // Minimal JavaScript glue - just calls the Lisp function
      // Define this BEFORE creating the widget so it's available when the button is clicked
      window.makeHttpRequest = async () => {
        console.log('makeHttpRequest called');
        try {
          const ctx = await initWisp();
          
          // Ensure js.wisp is loaded
          if (!window.jsLoaded) {
            try {
              const response = await fetch('js.wisp');
              const jsCode = await response.text();
              const jsForms = ctx.readMany(jsCode);
              if (jsForms !== ctx.sys.zap) {
                let current = jsForms;
                while (current !== ctx.sys.nil) {
                  const form = ctx.api.wisp_heap_get_duo_head(ctx.heap, current) >>> 0;
                  const run = ctx.api.wisp_run_init(ctx.heap, form);
                  ctx.api.wisp_run_eval(ctx.heap, run, 4_000_000) >>> 0;
                  current = ctx.api.wisp_heap_get_duo_tail(ctx.heap, current) >>> 0;
                }
                window.jsLoaded = true;
              }
            } catch (e) {
              console.warn('Could not load js.wisp:', e);
            }
          }
          
          // Ensure *window* is set
          try {
            const setWindowCode = ctx.read('(try (set-symbol-value! (quote *window*) (js-global-this)) (catch (e k) nil))');
            const setWindowRun = ctx.api.wisp_run_init(ctx.heap, setWindowCode);
            ctx.api.wisp_run_eval(ctx.heap, setWindowRun, 4_000_000) >>> 0;
          } catch (e) {
            console.warn('Could not set *window*:', e);
          }
          
          // First test if js-call works at all
          console.log('Testing js-call with window.fetch...');
          const testCode = ctx.read('(js-call *window* "fetch" "https://api.github.com/users/octocat")');
          const testRun = ctx.api.wisp_run_init(ctx.heap, testCode);
          const testResult = ctx.api.wisp_run_eval(ctx.heap, testRun, 4_000_000) >>> 0;
          console.log('Direct js-call test result:', testResult, 'tag:', (testResult >>> 27) & 0x1f);
          
          // Call the Lisp function - it returns a promise that we need to handle
          console.log('Calling http-request Lisp function...');
          const requestCode = ctx.read('(http-request "http-url" "http-result")');
          const requestRun = ctx.api.wisp_run_init(ctx.heap, requestCode);
          const result = ctx.api.wisp_run_eval(ctx.heap, requestRun, 10_000_000) >>> 0; // More steps for async operations
          console.log('Lisp function returned:', result, 'zap?', result === ctx.sys.zap, 'nil?', result === ctx.sys.nil);
          
          if (result === ctx.sys.zap) {
            // Fallback error message if Lisp fails
            document.getElementById('http-result').innerHTML = '<span style="color: red;">Error: Request failed</span>';
            return;
          }
          
          if (result === ctx.sys.nil) {
            // Function returned nil (probably empty URL or error)
            return;
          }
          
          // Extract the promise from the external object
          const tags = { ext: 0x1e };
          const promiseTag = (result >>> 27) & 0x1f;
          console.log('Result tag:', promiseTag.toString(16), 'expected ext:', tags.ext.toString(16));
          
          if (promiseTag === tags.ext) {
            const extIdx = ctx.api.wisp_heap_get_ext_idx(ctx.heap, result) >>> 0;
            const wasd = window.wasd;
            if (wasd && wasd.ext) {
              const jsPromise = wasd.ext.get(extIdx);
              console.log('Got promise from fetch, handling response...');
              if (jsPromise && typeof jsPromise.then === 'function') {
                // Handle the promise in JavaScript - get response and update DOM using Lisp
                jsPromise
                  .then(async (response) => {
                    const text = await response.text();
                    // Use Lisp to update the DOM
                    const formatted = `<span style="color: #4CAF50;">‚úì Success</span>\n\n<strong>Response:</strong>\n<pre style="color: #e0e0e0;">${escapeHtml(text)}</pre>`;
                    const escaped = formatted.replace(/"/g, '\\"').replace(/\n/g, '\\n');
                    const updateCode = ctx.read(`(element-set-html "http-result" "${escaped}")`);
                    const updateRun = ctx.api.wisp_run_init(ctx.heap, updateCode);
                    const updateResult = ctx.api.wisp_run_eval(ctx.heap, updateRun, 4_000_000) >>> 0;
                    if (updateResult === ctx.sys.zap) {
                      // Fallback to JavaScript if Lisp fails
                      document.getElementById('http-result').innerHTML = formatted;
                      document.getElementById('http-result').style.color = '#e0e0e0';
                    }
                  })
                  .catch((error) => {
                    console.error('Fetch failed:', error);
                    const errorMsg = `<span style="color: red;">‚úó Error</span>\n\n${escapeHtml(error.message)}`;
                    const escaped = errorMsg.replace(/"/g, '\\"').replace(/\n/g, '\\n');
                    const errorCode = ctx.read(`(element-set-html "http-result" "${escaped}")`);
                    const errorRun = ctx.api.wisp_run_init(ctx.heap, errorCode);
                    const errorResult = ctx.api.wisp_run_eval(ctx.heap, errorRun, 4_000_000) >>> 0;
                    if (errorResult === ctx.sys.zap) {
                      // Fallback to JavaScript if Lisp fails
                      document.getElementById('http-result').innerHTML = errorMsg;
                      document.getElementById('http-result').style.color = '#e0e0e0';
                    }
                  });
              }
            }
          } else {
            console.log('Result is not a promise, got tag:', promiseTag.toString(16));
          }
        } catch (error) {
          console.error('HTTP request error:', error);
          const resultDiv = document.getElementById('http-result');
          if (resultDiv) {
            resultDiv.innerHTML = `<span style="color: red;">Error: ${escapeHtml(error.message)}</span>`;
            resultDiv.style.color = '#e0e0e0';
          }
        }
      };

      const widget = document.createElement('div');
      widget.className = 'widget';
      widget.innerHTML = `
        <h2>üåê HTTP Request</h2>
        <p>Make HTTP requests using Lisp</p>
        <input type="text" id="http-url" value="https://api.github.com/users/octocat" style="width: 100%; padding: 8px; margin: 10px 0; box-sizing: border-box;">
        <button onclick="makeHttpRequest()" style="width: 100%; padding: 10px; font-size: 16px;">Fetch</button>
        <div class="result" id="http-result" style="margin-top: 15px; padding: 10px; background: #1e1e1e; border-radius: 5px; max-height: 400px; overflow-y: auto; white-space: pre-wrap; font-family: monospace; font-size: 12px; color: #e0e0e0;">Click "Fetch" to make a request...</div>
      `;

      return widget;
    }

    // Fibonacci Widget (pure Lisp)
    async function createFibonacciWidget() {
      const ctx = await initWisp();
      const widget = document.createElement('div');
      widget.className = 'widget';
      widget.innerHTML = `
        <h2>üî¢ Fibonacci Generator</h2>
        <p>Calculate Fibonacci numbers using Lisp recursion</p>
        <input type="number" id="fib-input" value="10" min="0" max="30" style="width: 100px;">
        <button onclick="calculateFib()">Calculate</button>
        <div class="result" id="fib-result">Enter a number and click Calculate</div>
        <div class="result" id="fib-sequence" style="max-height: 200px; overflow-y: auto;"></div>
      `;

      window.calculateFib = async () => {
        const n = parseInt(document.getElementById('fib-input').value) || 0;
        const resultDiv = document.getElementById('fib-result');
        const seqDiv = document.getElementById('fib-sequence');
        
        try {
          // Define fibonacci function in Lisp and call it
          // We need to evaluate the defun first, then call it
          const defunCode = `
            (defun fib (n)
              (if (< n 2)
                  n
                (+ (fib (- n 1)) (fib (- n 2)))))
          `;
          
          // Evaluate the function definition
          const defunSrc = ctx.read(defunCode);
          const defunRun = ctx.api.wisp_run_init(ctx.heap, defunSrc);
          const defunResult = ctx.api.wisp_run_eval(ctx.heap, defunRun, 4_000_000) >>> 0;
          
          if (defunResult === ctx.sys.zap) {
            resultDiv.innerHTML = '<span style="color: red;">Error: Function definition failed</span>';
            return;
          }
          
          // Now call the function
          const callCode = `(fib ${n})`;
          
          const callSrc = ctx.read(callCode);
          const callRun = ctx.api.wisp_run_init(ctx.heap, callSrc);
          const result = ctx.api.wisp_run_eval(ctx.heap, callRun, 4_000_000) >>> 0;

          if (result === ctx.sys.zap) {
            resultDiv.innerHTML = '<span style="color: red;">Error: Calculation failed</span>';
            return;
          }

          const fibValue = formatResult(ctx, result);
          resultDiv.innerHTML = `<strong>Fibonacci(${n}) = ${fibValue}</strong>`;
          
          // Generate sequence
          let sequence = [];
          for (let i = 0; i <= Math.min(n, 15); i++) {
            try {
              // Function is already defined, just call it
              const seqCallCode = `(fib ${i})`;
              const seqCallSrc = ctx.read(seqCallCode);
              const seqCallRun = ctx.api.wisp_run_init(ctx.heap, seqCallSrc);
              const seqResult = ctx.api.wisp_run_eval(ctx.heap, seqCallRun, 4_000_000) >>> 0;
              if (seqResult !== ctx.sys.zap) {
                sequence.push(formatResult(ctx, seqResult));
              }
            } catch (e) {
              break;
            }
          }
          
          seqDiv.innerHTML = `<strong>Sequence:</strong> ${sequence.join(', ')}`;
        } catch (error) {
          resultDiv.innerHTML = `<span style="color: red;">Error: ${escapeHtml(error.message)}</span>`;
        }
      };

      return widget;
    }

    // Initialize and create widgets
    async function init() {
      await initWisp();
      
      const container = document.getElementById('widgets');
      container.appendChild(createCalculator());
      container.appendChild(createTodoList());
      container.appendChild(await createLispRunner());
      container.appendChild(await createHttpRequestWidget());
      container.appendChild(await createLispCounter());
      container.appendChild(await createFibonacciWidget());
    }

    init();
  </script>
</body>
</html>

